#!/usr/bin/make -f

GITHUB_TOKEN := $(shell composer config -l -g | grep github-oauth.github.com | awk '{print $$2}')
# Modify the name of the application based on your needs
# This name should be identical to the main service in docker-compose.yml
MAIN_SERVICE := calculator
TEST_SERVICES :=

.env: scripts/env
	scripts/env local

vendor:
	composer install

# Create and start all containers along with migrations.
.PHONY: service.up
service.up:
	GITHUB_TOKEN=$(GITHUB_TOKEN) docker-compose up -d
	docker-compose exec -e APP_ENV=testing $(MAIN_SERVICE) php artisan migrate

# Stop and remove containers, networks.
.PHONY: service.down
service.down:
	@docker-compose down -v

# Build the project and image.
.PHONY: service.build
service.build: service.down vendor .env
ifdef GITHUB_TOKEN
	docker-compose build --build-arg GITHUB_TOKEN=$(GITHUB_TOKEN) $(MAIN_SERVICE)
else
	@echo ">>> Please pass the env var, the command will like 'make service.build GITHUB_TOKEN=xxx' ...";
	@exit 1
endif

# Create and start api container merely.
.PHONY: api.up
api.up:
	GITHUB_TOKEN=$(GITHUB_TOKEN) docker-compose up -d --no-deps $(MAIN_SERVICE)

# Create and start api container with xdebug config.
.PHONY: api.up.debug
api.up.debug: export XDEBUG_MODE=develop,coverage,debug,profile
api.up.debug: api.up

.PHONY: api.down
api.down:
	docker-compose rm -fsv $(MAIN_SERVICE)

.PHONY: api.restart
api.restart: api.down api.up

# Open the bash terminal of api container.
.PHONY: api.bash
api.bash:
	docker-compose exec $(MAIN_SERVICE) bash

# Alias for the "service.up" target.
.PHONY: test.up
test.up: service.up

# Stop and remove containers for test.
.PHONY: test.down
test.down:
	docker-compose rm -fsv $(TEST_SERVICES)

# Run test.
.PHONY: test
test:
	docker-compose exec -e APP_ENV=testing $(MAIN_SERVICE) php artisan test -d memory_limit=-1

# Refresh database for test.
.PHONY: test.refreshdb
test.refreshdb:
	docker-compose exec -e APP_ENV=testing $(MAIN_SERVICE) php artisan migrate:refresh

# Generate test coverage report.
.PHONY: test.coverage
test.coverage:
	docker-compose exec \
		-e APP_ENV=testing \
		-e XDEBUG_MODE=coverage \
		$(MAIN_SERVICE) php artisan test --coverage -d memory_limit=-1

# Generate test coverage html file report.
.PHONY: test.coverage.html
test.coverage.html:
	docker-compose exec \
		-e APP_ENV=testing \
		-e XDEBUG_MODE=coverage \
		$(MAIN_SERVICE) php vendor/bin/pest --coverage-html code-coverage -d memory_limit=-1

# Run phpcs.
.PHONY: test.phpcs
test.phpcs:
	docker-compose exec -e APP_ENV=testing $(MAIN_SERVICE) php vendor/bin/phpcs

# Building image in local for testing
#
# STAGE = (base | deploy | local | dev | stage | production)
# make  STAGE=${ENV} IMAGE_NAME=test:beta image.build
.PHONY: image.build
image.build:
	docker build --target=${STAGE} \
		--tag ${IMAGE_NAME} \
		--build-arg GITHUB_TOKEN=$(GITHUB_TOKEN) \
 		--file ./Dockerfile .

# Scan the image file for vulnerabilities.
# Prerequisite: You need to download `trivy`
# Please refer https://github.com/104corp/image-scan/blob/main/scan.sh
#
# Exampleï¼šmake IMAGE_NAME=test:beta image.scan
.PHONY: image.scan
image.scan:
	trivy image --severity CRITICAL --vuln-type os --ignore-unfixed ${IMAGE_NAME}

# Refresh the file generated by laravel ide helper.
.PHONY: ide.refresh
ide.refresh:
	docker-compose exec $(MAIN_SERVICE) php artisan clear-compiled
	docker-compose exec $(MAIN_SERVICE) php artisan ide-helper:generate
